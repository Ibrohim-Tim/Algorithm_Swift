# Алгоритмы Swift
___
## Задача с перемещением 0 в конец массива:

```swift
 class Solution {
    func moveZeroes(_ nums: inout [Int]) {
        var nonZeroIndex = 0
        
        // Переместим все ненулевые элементы в начало массива
        for num in nums {
            if num != 0 {
                nums[nonZeroIndex] = num
                nonZeroIndex += 1
            }
        }
        
        // Заполним оставшуюся часть массива нулями
        while nonZeroIndex < nums.count {
            nums[nonZeroIndex] = 0
            nonZeroIndex += 1
        }
    }
}
```
___
## Задача с выведением числа, с самым частым повторением:

Для достижения временной сложности O(1), мы можем воспользоваться алгоритмом Мура для поиска большинства элемента в массиве. Этот алгоритм позволяет найти элемент, который встречается более чем n/2 раз, где n - это размер массива.

### Алгоритм Мура работает следующим образом:

Инициализируем переменные candidate и count. На каждой итерации массива:
- Если count равно 0, мы делаем текущий элемент кандидатом.
- Если текущий элемент равен кандидату, мы увеличиваем count, в противном случае мы уменьшаем count.

В конце процесса candidate будет элементом, который встречается больше, чем n/2 раз, если такой элемент существует.
Вот реализация на Swift:

``` swift
class Solution {
    func majorityElement(_ nums: [Int]) -> Int {
        var candidate: Int?
        var count = 0
        
        for num in nums {
            if count == 0 {
                candidate = num
                count = 1
            } else if candidate == num {
                count += 1
            } else {
                count -= 1
            }
        }
        
        return candidate!
    }
}

// Пример использования:
let solution = Solution()
let nums = [3, 3, 4, 2, 4, 4, 2, 4, 4]
print(solution.majorityElement(nums)) // Output: 4
```
Это решение имеет временную сложность O(n) и использует константное количество дополнительной памяти, что соответствует требованию O(1).
___
## Задача по возвращению максимальной прибыли, которую вы можете получить от сделки: 
Например: дан массив цены [7, 1, 5, 3, 6, 4]. Покупайте в день 2 (цена = 1) и продавайте в день 5 (цена = 6), прибыль = 6-1 = 5. 
Обратите внимание, что покупка во второй день и продажа в первый день не разрешены, поскольку вы должны купить, прежде чем продавать. Если мы не можем получить никакой прибыли, возвращаем 0.

``` swift
class Solution {
    func maxProfit(_ prices: [Int]) -> Int {
        if prices.isEmpty {
            return 0 // Возвращаем 0, если массив пустой
        }
        
        var maxProfit = 0
        var minPrice = prices[0] // Изначально устанавливаем минимальную цену как первый элемент массива
        
        for price in prices {
            minPrice = min(minPrice, price) // Обновляем минимальную цену, если текущая цена меньше
            maxProfit = max(maxProfit, price - minPrice) // Обновляем максимальную прибыль, если текущая прибыль больше
        }
        
        return maxProfit
    }
}
```
___